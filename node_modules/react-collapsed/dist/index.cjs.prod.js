"use strict";var pe=Object.create;var w=Object.defineProperty,ge=Object.defineProperties,me=Object.getOwnPropertyDescriptor,ye=Object.getOwnPropertyDescriptors,he=Object.getOwnPropertyNames,H=Object.getOwnPropertySymbols,xe=Object.getPrototypeOf,F=Object.prototype.hasOwnProperty,J=Object.prototype.propertyIsEnumerable;var G=(e,t,n)=>t in e?w(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))F.call(t,n)&&G(e,n,t[n]);if(H)for(var n of H(t))J.call(t,n)&&G(e,n,t[n]);return e},X=(e,t)=>ge(e,ye(t));var Z=(e,t)=>{var n={};for(var r in e)F.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&H)for(var r of H(e))t.indexOf(r)<0&&J.call(e,r)&&(n[r]=e[r]);return n};var be=(e,t)=>{for(var n in t)w(e,n,{get:t[n],enumerable:!0})},ee=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of he(t))!F.call(e,o)&&o!==n&&w(e,o,{get:()=>t[o],enumerable:!(r=me(t,o))||r.enumerable});return e};var te=(e,t,n)=>(n=e!=null?pe(xe(e)):{},ee(t||!e||!e.__esModule?w(n,"default",{value:e,enumerable:!0}):n,e)),Ee=e=>ee(w({},"__esModule",{value:!0}),e);var He={};be(He,{useCollapse:()=>Ie});module.exports=Ee(He);var d=require("react");var ie=require("react");var ne=te(require("tiny-warning")),K=class extends Error{constructor(t){super(`react-collapsed: ${t}`)}},b=(...e)=>(0,ne.default)(e[0],`[react-collapsed] -- ${e[1]}`);var E=require("react");function A(e){let t=(0,E.useRef)(e);return(0,E.useEffect)(()=>{t.current=e}),(0,E.useCallback)((...n)=>{var r;return(r=t.current)==null?void 0:r.call(t,...n)},[])}var y=require("react");function $(e,t,n){let[r,o]=(0,y.useState)(t),f=(0,y.useRef)(typeof e!="undefined"),R=f.current?e:r,T=A(n),P=(0,y.useCallback)(p=>{let a=typeof p=="function"?p(R):p;f.current||o(a),T==null||T(a)},[T,R]);return(0,y.useEffect)(()=>{b(!(f.current&&e==null),"`isExpanded` state is changing from controlled to uncontrolled. useCollapse should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop."),b(!(!f.current&&e!=null),"`isExpanded` state is changing from uncontrolled to controlled. useCollapse should not switch from uncontrolled to controlled (or vice versa). Decide between using a controlled or uncontrolled collapse for the lifetime of the component. Check the `isExpanded` prop.")},[e]),[R,P]}var M=require("react"),Re="(prefers-reduced-motion: reduce)";function V(){let[e,t]=(0,M.useState)(!1);return(0,M.useEffect)(()=>{let n=window.matchMedia(Re);t(n.matches);let r=o=>{t(o.matches)};return n.addEventListener("change",r),()=>{n.removeEventListener("change",r)}},[]),e}var h=te(require("react")),Te=h["useId".toString()]||(()=>{});function ve(){let e=Te();return e!=null?e:""}var Ce=typeof window!="undefined"?h.useLayoutEffect:h.useEffect,q=!1,Se=0,re=()=>++Se;function we(e){let t=e||(q?re():null),[n,r]=h.useState(t);return Ce(()=>{n===null&&r(re())},[]),h.useEffect(()=>{q===!1&&(q=!0)},[]),n!=null?String(n):void 0}function j(e){let t=ve(),n=we(e);return typeof e=="string"?e:typeof t=="string"?t:n}function oe(e,t){let n=performance.now(),r={};function o(){r.id=requestAnimationFrame(f=>{f-n>t?e():o()})}return o(),r}function O(e){e.id&&cancelAnimationFrame(e.id)}function B(e){return e!=null&&e.current?e.current.scrollHeight:(b(!0,"Was not able to find a ref to the collapse element via `getCollapseProps`. Ensure that the element exposes its `ref` prop. If it exposes the ref prop under a different name (like `innerRef`), use the `refKey` property to change it. Example:\n\nconst collapseProps = getCollapseProps({refKey: 'innerRef'})"),0)}function se(e){if(!e||typeof e=="string")return 0;let t=e/36;return Math.round((4+15*t**.25+t/5)*10)}function Ae(e,t){if(e!=null)if(typeof e=="function")e(t);else try{e.current=t}catch(n){throw new K(`Cannot assign value "${t}" to ref "${e}"`)}}function U(...e){return e.every(t=>t==null)?null:t=>{e.forEach(n=>{Ae(n,t)})}}function ae(e){let t=n=>{};!1!=="production"&&(t=n=>{if(!(n!=null&&n.current))return;let{paddingTop:r,paddingBottom:o}=window.getComputedStyle(n.current);b(!(r&&r!=="0px"||o&&o!=="0px"),`Padding applied to the collapse element will cause the animation to break and not perform as expected. To fix, apply equivalent padding to the direct descendent of the collapse element. Example:

Before:   <div {...getCollapseProps({style: {padding: 10}})}>{children}</div>

After:   <div {...getCollapseProps()}>
             <div style={{padding: 10}}>
                 {children}
             </div>
          </div>`)}),(0,ie.useEffect)(()=>{t(e)},[e])}var Pe=typeof window=="undefined"?d.useEffect:d.useLayoutEffect;function Ie(T={}){var P=T,{duration:e,easing:t="cubic-bezier(0.4, 0, 0.2, 1)",onTransitionStateChange:n=()=>{},isExpanded:r,defaultExpanded:o=!1,hasDisabledAnimation:f}=P,R=Z(P,["duration","easing","onTransitionStateChange","isExpanded","defaultExpanded","hasDisabledAnimation"]);let p=A(n),I=j(),[a,D]=$(r,o),N=(0,d.useRef)(a),[le,W]=(0,d.useState)(!1),ue=V(),Q=f!=null?f:ue,x=(0,d.useRef)(),v=(0,d.useRef)(),g=(0,d.useRef)(null),[_,ce]=(0,d.useState)(null);ae(g);let C=`${R.collapsedHeight||0}px`;function S(s){if(!g.current)return;let l=g.current;for(let u in s){let m=s[u];m?l.style[u]=m:l.style.removeProperty(u)}}return Pe(()=>{if(!g.current||a===N.current)return;N.current=a;function l(i){return Q?0:e!=null?e:se(i)}let u=i=>`height ${l(i)}ms ${t}`,m=i=>{function k(){a?(S({height:"",overflow:"",transition:"",display:""}),p("expandEnd")):(S({transition:""}),p("collapseEnd")),W(!1)}v.current&&O(v.current),v.current=oe(k,i)};return W(!0),a?x.current=requestAnimationFrame(()=>{p("expandStart"),S({display:"block",overflow:"hidden",height:C}),x.current=requestAnimationFrame(()=>{p("expanding");let i=B(g);m(l(i)),g.current&&(g.current.style.transition=u(i),g.current.style.height=`${i}px`)})}):x.current=requestAnimationFrame(()=>{p("collapseStart");let i=B(g);m(l(i)),S({transition:u(i),height:`${i}px`}),x.current=requestAnimationFrame(()=>{p("collapsing"),S({height:C,overflow:"hidden"})})}),()=>{x.current&&cancelAnimationFrame(x.current),v.current&&O(v.current)}},[a,C,Q,e,t,p]),{isExpanded:a,setExpanded:D,getToggleProps(s){let{disabled:l,onClick:u,refKey:m}=c({refKey:"ref",onClick(){},disabled:!1},s),i=_?_.tagName==="BUTTON":void 0,k=s==null?void 0:s[m||"ref"],L={id:`react-collapsed-toggle-${I}`,"aria-controls":`react-collapsed-panel-${I}`,"aria-expanded":a,onClick(de){l||(u==null||u(de),D(fe=>!fe))},[m||"ref"]:U(k,ce)},z={type:"button",disabled:l?!0:void 0},Y={"aria-disabled":l?!0:void 0,role:"button",tabIndex:l?-1:0};return i===!1?c(c({},L),Y):i===!0?c(c({},L),z):c(c(c({},L),z),Y)},getCollapseProps(s){let{style:l,refKey:u}=c({refKey:"ref",style:{}},s),m=s==null?void 0:s[u||"ref"];return X(c({id:`react-collapsed-panel-${I}`,"aria-hidden":!a,role:"region"},s),{[u||"ref"]:U(g,m),style:c(c({boxSizing:"border-box"},!le&&!a?{display:C==="0px"?"none":"block",height:C,overflow:"hidden"}:{}),l)})}}}0&&(module.exports={useCollapse});
